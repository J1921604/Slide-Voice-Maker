<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slide Voice Maker - AI音声付き動画生成ツール (WebM/MP4)</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pptxgenjs/dist/pptxgen.bundle.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #0b0f16; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #f97316; border-radius: 3px; }
        @keyframes aurora-1 { 0%, 100% { transform: translate(0, 0) scale(1); } 50% { transform: translate(24px, -18px) scale(1.12); } }
        @keyframes aurora-2 { 0%, 100% { transform: translate(0, 0) scale(1); } 50% { transform: translate(-18px, 14px) scale(1.18); } }
        .animate-aurora-1 { animation: aurora-1 16s infinite ease-in-out; }
        .animate-aurora-2 { animation: aurora-2 20s infinite ease-in-out; }
        .loading-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .metal-panel {
            background: linear-gradient(135deg, #0d0f14 0%, #12141c 45%, #0b0c11 100%);
            border: 1px solid rgba(249, 115, 22, 0.25);
            box-shadow: 0 10px 30px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.04), 0 0 25px rgba(249, 115, 22, 0.12);
        }
        .orange-glow {
            box-shadow: 0 0 0 1px rgba(249, 115, 22, 0.3), 0 10px 25px rgba(249, 115, 22, 0.22);
        }
        .bg-grid {
            background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,0.08) 1px, transparent 0);
            background-size: 36px 36px;
        }
    </style>
</head>
<body class="bg-slate-950">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo } = React;

        // サーバー連携モード
        const isLocalMode = true;

        // Icons
        const Upload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
        const FileText = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>;
        const Play = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
        const Square = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>;
        const Video = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>;
        const Download = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const Volume2 = () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>;
        const HelpCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>;
        const X = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>;
        const ChevronLeft = () => <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6"/></svg>;
        const ChevronRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"/></svg>;
        const Loader2 = ({ className }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"/><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"/><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"/></svg>;
        const Wand2 = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></svg>;

        // 字幕セグメント分割
        const getSubtitleSegments = (script) => {
            if (!script) return [];
            const rawSegments = script.split(/([。、！？!?\n]+)/).filter(s => s.trim().length > 0);
            const mergedSegments = [];
            for (let i = 0; i < rawSegments.length; i += 2) {
                const text = rawSegments[i];
                const punctuation = rawSegments[i + 1] || "";
                mergedSegments.push(text + punctuation);
            }
            const totalChars = mergedSegments.reduce((acc, s) => acc + s.length, 0);
            let charCountAccumulator = 0;
            return mergedSegments.map(text => {
                const startRatio = charCountAccumulator / totalChars;
                charCountAccumulator += text.length;
                const endRatio = charCountAccumulator / totalChars;
                return { text, startRatio, endRatio };
            });
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        const fetchJson = async (url, options = {}, timeoutMs = 180000) => {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeoutMs);
            try {
                const res = await fetch(url, { ...options, signal: ctrl.signal });
                if (!res.ok) {
                    const text = await res.text().catch(() => '');
                    throw new Error(`${res.status} ${res.statusText}${text ? `: ${text}` : ''}`);
                }
                return await res.json();
            } catch (err) {
                if (err.name === 'AbortError') {
                    throw new Error(`タイムアウト（${timeoutMs/1000}秒超過）: サーバー応答がありませんでした。音声合成モデルの初回ロード時は時間がかかる場合があります。`);
                }
                throw err;
            } finally {
                clearTimeout(t);
            }
        };

        // PlayerOverlay
        const PlayerOverlay = ({ currentSlide, audioRef, isPlaying }) => {
            const [currentSubtitle, setCurrentSubtitle] = useState("");
            const subtitleSegments = useMemo(() => getSubtitleSegments(currentSlide?.script), [currentSlide]);
            
            useEffect(() => {
                const audio = audioRef.current;
                if (!audio) return;
                const handleTimeUpdate = () => {
                    if (!currentSlide?.audio) { setCurrentSubtitle(""); return; }
                    const duration = audio.duration;
                    const currentTime = audio.currentTime;
                    if (!duration || !isFinite(duration)) return;
                    const currentRatio = currentTime / duration;
                    const activeSegment = subtitleSegments.find(seg => currentRatio >= seg.startRatio && currentRatio < seg.endRatio);
                    if (activeSegment) setCurrentSubtitle(activeSegment.text);
                    else if (currentRatio >= 1 && subtitleSegments.length > 0) setCurrentSubtitle(subtitleSegments[subtitleSegments.length - 1].text);
                };
                audio.addEventListener('timeupdate', handleTimeUpdate);
                return () => audio.removeEventListener('timeupdate', handleTimeUpdate);
            }, [audioRef, currentSlide, subtitleSegments]);
            
            return (
                <div className="w-full h-[56px] bg-transparent border-t border-amber-500/20 flex items-end justify-center px-4 pb-2 transition-colors duration-300 flex-shrink-0">
                    <div className="max-w-[min(92vw,56rem)] px-4 py-2 rounded-md bg-black/60 backdrop-blur-sm text-amber-100 text-base md:text-lg font-bold text-center leading-snug shadow-xl shadow-amber-500/25 border border-amber-500/25">
                        {currentSubtitle}
                    </div>
                </div>
            );
        };

        // Main App
        function SlideVoiceMaker() {
            const [slides, setSlides] = useState([]);
            const [scripts, setScripts] = useState([]);
            const [activeSlideIndex, setActiveSlideIndex] = useState(0);
            const [pdfLoading, setPdfLoading] = useState(false);
            const [showHelp, setShowHelp] = useState(false);
            const [isPlaying, setIsPlaying] = useState(false);
            const [isGeneratingAudio, setIsGeneratingAudio] = useState(false);
            const [isGeneratingVideo, setIsGeneratingVideo] = useState(false);
            const [pdfFile, setPdfFile] = useState(null);
            const [csvFile, setCsvFile] = useState(null);
            const [statusMessage, setStatusMessage] = useState('');
            const [selectedResolution, setSelectedResolution] = useState('720p');
            const [voiceGender, setVoiceGender] = useState('女声1');
            const [playbackRate, setPlaybackRate] = useState(1.0);
            const [subtitleEnabled, setSubtitleEnabled] = useState(true);  // 字幕ON/OFF
            const [videoFormat, setVideoFormat] = useState('webm'); // webm / mp4

            // Local backend state
            const [localBackendAvailable, setLocalBackendAvailable] = useState(false);
            const [savedPdfName, setSavedPdfName] = useState('');
            const [outputFiles, setOutputFiles] = useState([]);
            const [selectedOutputName, setSelectedOutputName] = useState('');
            
            // 解像度マッピング
            const RESOLUTION_OPTIONS = [
                { label: '1280x720', value: '720p', width: 1280, height: 720 },
                { label: '1920x1080', value: '1080p', width: 1920, height: 1080 },
                { label: '2560x1440', value: '1440p', width: 2560, height: 1440 },
            ];
            
            const audioRef = useRef(null);
            const fileInputRef = useRef(null);
            const csvInputRef = useRef(null);
            const dictInputRef = useRef(null);

            // 発音辞書の状態
            const [pronounceDict, setPronounceDict] = useState([]);

            const refreshOutputFiles = async () => {
                if (!localBackendAvailable) return;
                try {
                    const list = await fetchJson('/api/list_outputs', {}, 4000);
                    const webm = (list && list.webm) ? list.webm : [];
                    const mp4 = (list && list.mp4) ? list.mp4 : [];
                    const files = [...webm, ...mp4].sort();
                    setOutputFiles(files);
                    if (!selectedOutputName && files.length > 0) {
                        setSelectedOutputName(files[files.length - 1]);
                    }
                } catch (_) {
                    // noop
                }
            };

            const shortenOutputLabel = (name) => {
                if (!name) return '';
                const base = String(name).replace(/\.(webm|mp4)$/i, '');
                if (base.length <= 24) return base;
                return `${base.slice(0, 12)}…${base.slice(-8)}`;
            };

            const downloadSelectedVideo = () => {
                if (!localBackendAvailable) return;
                if (!selectedOutputName) {
                    setStatusMessage('ダウンロードする動画（WebM/MP4）を選択してください');
                    return;
                }
                const a = document.createElement('a');
                a.href = `/api/download?name=${encodeURIComponent(selectedOutputName)}`;
                a.download = selectedOutputName;
                a.rel = 'noopener';
                document.body.appendChild(a);
                a.click();
                a.remove();
            };

            // PPTX出力（ブラウザで生成してダウンロード）
            const exportPptx = async () => {
                if (slides.length === 0) {
                    setStatusMessage('スライドがありません');
                    return;
                }
                const pdfBaseName = savedPdfName ? savedPdfName.replace(/\.pdf$/i, '') : 'slides';

                const PptxGenJS = window.PptxGenJS;
                if (!PptxGenJS) {
                    setStatusMessage('PPTXライブラリが読み込まれていません（PptxGenJS）');
                    return;
                }

                try {
                    setStatusMessage('PPTXを書き出し中...');
                    const pptx = new PptxGenJS();
                    pptx.layout = 'LAYOUT_WIDE';

                    // 16:9 (13.333 x 7.5)
                    const W = 13.333;
                    const H = 7.5;

                    slides.forEach((s, i) => {
                        const slide = pptx.addSlide();
                        if (s && s.image) {
                            slide.addImage({ data: s.image, x: 0, y: 0, w: W, h: H });
                        }
                        const note = (s && s.script) ? String(s.script) : '';
                        if (note) {
                            slide.addNotes(note);
                        }
                    });

                    await pptx.writeFile({ fileName: `${pdfBaseName}.pptx` });
                    setStatusMessage(`PPTX出力完了: ${pdfBaseName}.pptx`);
                } catch (e) {
                    setStatusMessage(`PPTX出力失敗: ${e.message}`);
                }
            };

            // 原稿CSV出力
            const downloadCsv = () => {
                if (slides.length === 0) {
                    setStatusMessage('スライドがありません');
                    return;
                }
                const lines = ['index,script'];
                slides.forEach((slide, i) => {
                    const escaped = (slide.script || '').replace(/"/g, '""');
                    lines.push(`${i},"${escaped}"`);
                });
                const csvContent = '\uFEFF' + lines.join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = '原稿.csv';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                setStatusMessage('原稿CSVをダウンロードしました');
            };

            // 再生速度をaudioRefに適用（playbackRateまたはactiveSlideIndex変更時）
            useEffect(() => {
                if (audioRef.current) {
                    audioRef.current.playbackRate = playbackRate;
                }
            }, [playbackRate, activeSlideIndex]);

            // ローカルバックエンド検出 + TTSウォームアップ
            useEffect(() => {
                let cancelled = false;
                const check = async () => {
                    try {
                        const j = await fetchJson('/api/health', {}, 1200);
                        if (!cancelled && j && j.status === 'ok') {
                            setLocalBackendAvailable(true);
                            // TTSモデルを事前ロード（バックグラウンド）
                            fetchJson('/api/warmup_tts', { method: 'POST' }, 120000).catch(() => {
                                console.warn('TTS warmup failed, will load on first use');
                            });
                        }
                    } catch (_) {
                        if (!cancelled) setLocalBackendAvailable(false);
                    }
                };
                check();
                return () => { cancelled = true; };
            }, []);

            // PDF to Images (arrayBufferを直接受け取る)
            const convertPdfToImages = async (arrayBuffer) => {
                const pdfjsLib = window.pdfjsLib;
                if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                }
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const images = [];
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport }).promise;
                    images.push(canvas.toDataURL('image/png'));
                }
                return images;
            };

            // CSV Parser (文字化け対処・マルチライン対応) - arrayBufferを直接受け取る
            const parseCSVFromBuffer = async (buf) => {
                const encodings = ['utf-8', 'utf-8-sig', 'shift_jis', 'euc-jp', 'iso-2022-jp'];

                const decodeWith = (encoding) => {
                    try {
                        const dec = new TextDecoder(encoding, { fatal: false });
                        return dec.decode(buf);
                    } catch (_) {
                        return null;
                    }
                };

                // RFC 4180最小対応（複数行セル/エスケープ引用符）
                const parseText = (text) => {
                    const rows = [];
                    let row = [];
                    let field = '';
                    let inQuotes = false;

                    for (let i = 0; i < text.length; i++) {
                        const ch = text[i];
                        const next = text[i + 1];

                        if (ch === '"') {
                            if (inQuotes && next === '"') {
                                field += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                            continue;
                        }

                        if (!inQuotes && (ch === ',' || ch === '\n' || ch === '\r')) {
                            row.push(field);
                            field = '';

                            if (ch === ',') {
                                continue;
                            }

                            if (ch === '\r' && next === '\n') i++;
                            rows.push(row);
                            row = [];
                            continue;
                        }

                        field += ch;
                    }

                    if (field.length > 0 || row.length > 0) {
                        row.push(field);
                        rows.push(row);
                    }

                    if (rows.length === 0) return [];

                    // ヘッダー行からindex列とscript列の位置を特定
                    // 重要: script列のテキストのみを抽出し、他の列（index等）は音声生成に使用しない
                    const header = rows[0].map(v => (v || '').trim().toLowerCase());
                    const idxCol = header.indexOf('index');
                    const scriptCol = header.indexOf('script');
                    if (idxCol === -1 || scriptCol === -1) return [];

                    const scripts = [];
                    for (let r = 1; r < rows.length; r++) {
                        const cols = rows[r];
                        if (!cols || cols.length === 0) continue;
                        const idxRaw = cols[idxCol];
                        const scriptRaw = cols[scriptCol];
                        const idx = Number.parseInt(String(idxRaw ?? '').trim(), 10);
                        if (Number.isNaN(idx)) continue;
                        // script列のテキストのみを抽出（index列の数値等は含まれない）
                        const script = String(scriptRaw ?? '').trim();
                        scripts.push({ index: idx, script });
                    }
                    return scripts;
                };

                for (const encoding of encodings) {
                    const text = decodeWith(encoding);
                    if (!text) continue;

                    const replacementCount = (text.match(/\uFFFD/g) || []).length;
                    if (replacementCount > 0 && replacementCount / Math.max(text.length, 1) > 0.001) {
                        continue;
                    }

                    const scripts = parseText(text);
                    if (scripts.length > 0) return scripts;
                }

                throw new Error('CSVの文字コードを認識できませんでした（UTF-8/Shift_JIS等を確認してください）');
            };

            // Handle PDF Upload
            const handlePdfUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setPdfFile(file);
                setPdfLoading(true);
                setStatusMessage('PDF読み込み中...');
                try {
                    // ファイル参照が失効する前にarrayBufferを先に取得
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // PDFファイル名を記録
                    setSavedPdfName(file.name);

                    // ローカルバックエンドがあれば input/ に保存
                    if (localBackendAvailable) {
                        try {
                            setStatusMessage('PDFをinput/へ保存中...');
                            const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                            const fd = new FormData();
                            fd.append('file', blob, file.name);
                            const res = await fetch('/api/upload/pdf', { method: 'POST', body: fd });
                            if (!res.ok) throw new Error(`PDF保存失敗: ${res.status}`);
                        } catch (e) {
                            console.warn('PDF保存に失敗しました', e);
                        }
                    }

                    const images = await convertPdfToImages(arrayBuffer);
                    const newSlides = images.map((image, index) => ({
                        id: crypto.randomUUID(),
                        image,
                        script: scripts[index]?.script || '',
                        audio: null,
                        isGenerating: false
                    }));
                    setSlides(newSlides);
                    setActiveSlideIndex(0);
                    setStatusMessage(`${images.length}ページのPDFを読み込みました`);
                } catch (error) {
                    setStatusMessage(`PDF読み込み失敗: ${error.message}`);
                } finally {
                    setPdfLoading(false);
                }
            };

            // Handle CSV Upload
            const handleCsvUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setCsvFile(file);
                setStatusMessage('原稿CSV読み込み中...');
                try {
                    // ファイル参照が失効する前にarrayBufferを先に取得
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // サーバー: input/ にCSVを上書き保存
                    if (localBackendAvailable) {
                        setStatusMessage('原稿.csvをinput/へ保存中...');
                        const blob = new Blob([arrayBuffer], { type: 'text/csv' });
                        const fd = new FormData();
                        fd.append('file', blob, file.name);
                        const res = await fetch('/api/upload/csv', { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(`CSV保存失敗: ${res.status}`);
                        setStatusMessage('CSV保存完了。ブラウザで原稿プレビュー反映中...');
                    }

                    // arrayBufferからCSVをパース
                    const parsedScripts = await parseCSVFromBuffer(arrayBuffer);
                    setScripts(parsedScripts);
                    
                    // スライドがあれば原稿を適用
                    if (slides.length > 0) {
                        setSlides(prev => prev.map((slide, index) => ({
                            ...slide,
                            script: parsedScripts.find(s => s.index === index)?.script || slide.script,
                            audio: null
                        })));
                    }
                    setStatusMessage(`${parsedScripts.length}件の原稿を読み込みました`);
                } catch (error) {
                    setStatusMessage(`CSV読み込み失敗: ${error.message}`);
                } finally {
                    // 同じファイルを再度選択できるようにinputをリセット
                    if (csvInputRef.current) csvInputRef.current.value = '';
                }
            };

            // Handle Dictionary Upload
            const handleDictUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setStatusMessage('発音辞書読み込み中...');
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // サーバー: input/ に発音辞書を上書き保存
                    if (localBackendAvailable) {
                        setStatusMessage('発音辞書.csvをinput/へ保存中...');
                        const blob = new Blob([arrayBuffer], { type: 'text/csv' });
                        const fd = new FormData();
                        fd.append('file', blob, file.name);
                        const res = await fetch('/api/upload/dict', { method: 'POST', body: fd });
                        if (!res.ok) throw new Error(`発音辞書保存失敗: ${res.status}`);
                    }

                    // arrayBufferから発音辞書をパース（word,alias形式）
                    const dict = await parseDictFromBuffer(arrayBuffer);
                    setPronounceDict(dict);
                    setStatusMessage(`${dict.length}件の発音辞書を読み込みました`);
                } catch (error) {
                    setStatusMessage(`発音辞書読み込み失敗: ${error.message}`);
                } finally {
                    if (dictInputRef.current) dictInputRef.current.value = '';
                }
            };

            // Parse Dictionary CSV from ArrayBuffer (word,alias format)
            const parseDictFromBuffer = async (arrayBuffer) => {
                const encodings = ['utf-8', 'shift-jis', 'euc-jp', 'iso-2022-jp'];
                
                const decodeWith = (encoding) => {
                    try {
                        const decoder = new TextDecoder(encoding, { fatal: false });
                        return decoder.decode(arrayBuffer);
                    } catch (e) {
                        return null;
                    }
                };

                const parseText = (text) => {
                    if (!text || text.trim().length === 0) return [];

                    // RFC4180最小準拠パーサー
                    const rows = [];
                    let row = [];
                    let field = '';
                    let inQuotes = false;

                    for (let i = 0; i < text.length; i++) {
                        const ch = text[i];
                        const next = i + 1 < text.length ? text[i + 1] : null;

                        if (ch === '"') {
                            if (inQuotes && next === '"') {
                                field += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                            continue;
                        }

                        if (!inQuotes && (ch === ',' || ch === '\n' || ch === '\r')) {
                            row.push(field);
                            field = '';

                            if (ch === ',') {
                                continue;
                            }

                            if (ch === '\r' && next === '\n') i++;
                            rows.push(row);
                            row = [];
                            continue;
                        }

                        field += ch;
                    }

                    if (field.length > 0 || row.length > 0) {
                        row.push(field);
                        rows.push(row);
                    }

                    if (rows.length === 0) return [];

                    // ヘッダー行を確認（word,aliasまたは単にデータ行）
                    const header = rows[0].map(v => (v || '').trim().toLowerCase());
                    const hasHeader = header.includes('word') && header.includes('alias');
                    const startRow = hasHeader ? 1 : 0;

                    const dict = [];
                    for (let r = startRow; r < rows.length; r++) {
                        const cols = rows[r];
                        if (!cols || cols.length < 2) continue;
                        
                        const word = String(cols[0] || '').trim();
                        const alias = String(cols[1] || '').trim();
                        
                        if (word && alias) {
                            dict.push({ word, alias });
                        }
                    }
                    return dict;
                };

                for (const encoding of encodings) {
                    const text = decodeWith(encoding);
                    if (!text) continue;

                    const replacementCount = (text.match(/\uFFFD/g) || []).length;
                    if (replacementCount > 0 && replacementCount / Math.max(text.length, 1) > 0.001) {
                        continue;
                    }

                    const dict = parseText(text);
                    if (dict.length > 0) return dict;
                }

                throw new Error('CSVの文字コードを認識できませんでした（UTF-8/Shift_JIS等を確認してください）');
            };

            // Generate All Audio (音声のみ生成)
            const generateAllAudio = async () => {
                if (isGeneratingAudio) return;

                if (!localBackendAvailable) {
                    setStatusMessage('ローカルバックエンド（src/server.py）が起動していません。');
                    return;
                }

                if (slides.length === 0) {
                    setStatusMessage('先にPDFをアップロードしてください');
                    return;
                }

                // PDFファイル名から拡張子を除いた名前を取得（tempスコープ）
                const pdfBaseName = savedPdfName ? savedPdfName.replace(/\.pdf$/i, '') : 'output';

                setIsGeneratingAudio(true);
                setStatusMessage('全スライドの音声生成中...');
                try {
                    // 要件: 画像・音声生成ボタン実行で output/temp 内の全ファイルを削除し上書き更新
                    setStatusMessage('output/temp をクリア中...');
                    await fetchJson('/api/clear_temp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    }, 30000);

                    // 全スライドの音声を生成（画像も送信）
                    for (let i = 0; i < slides.length; i++) {
                        const slide = slides[i];
                        setStatusMessage(`音声生成中... (${i + 1}/${slides.length}) ${i === 0 ? '初回はモデルロードに時間がかかります' : ''}`);
                        
                        // script列のテキストのみを使用（空の場合はスキップ）
                        const scriptText = (slide.script || '').trim();
                        
                        const body = JSON.stringify({ 
                            output_name: pdfBaseName,
                            slide_index: i, 
                            script: scriptText,
                            image_data: slide.image,
                            resolution: selectedResolution,
                            voice_gender: voiceGender,
                            pronounce_dict: pronounceDict,
                        });
                        const res = await fetchJson('/api/generate_audio', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body 
                        }, 300000);
                        
                        if (res && res.audio_url) {
                            setSlides(prev => {
                                const newSlides = [...prev];
                                newSlides[i] = { ...newSlides[i], audio: res.audio_url };
                                return newSlides;
                            });
                        }
                    }
                    setStatusMessage('音声生成完了。output/temp/ に保存しました。');
                } catch (e) {
                    setStatusMessage(`音声生成失敗: ${e.message}`);
                } finally {
                    setIsGeneratingAudio(false);
                }
            };

            // Generate Single Slide Audio (個別スライド音声生成)
            const generateSlideAudio = async (slideIndex) => {
                if (!localBackendAvailable) {
                    setStatusMessage('ローカルバックエンドが起動していません。');
                    return;
                }

                const slide = slides[slideIndex];
                if (!slide.script || slide.script.trim() === '') {
                    setStatusMessage('原稿が入力されていません。');
                    return;
                }

                setSlides(prev => {
                    const newSlides = [...prev];
                    newSlides[slideIndex] = { ...newSlides[slideIndex], isGenerating: true };
                    return newSlides;
                });
                setStatusMessage(`スライド ${slideIndex + 1} の音声生成中...`);

                try {
                    const pdfBaseName = savedPdfName ? savedPdfName.replace(/\.pdf$/i, '') : 'output';
                    // script列のテキストのみを使用
                    const scriptText = slide.script.trim();
                    
                    const body = JSON.stringify({ 
                        output_name: pdfBaseName,
                        slide_index: slideIndex, 
                        script: scriptText,
                        image_data: slide.image,
                        resolution: selectedResolution,
                        voice_gender: voiceGender,
                        pronounce_dict: pronounceDict,
                    });
                    const res = await fetchJson('/api/generate_audio', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body 
                    }, 300000);
                    
                    if (res && res.audio_url) {
                        setSlides(prev => {
                            const newSlides = [...prev];
                            newSlides[slideIndex] = { ...newSlides[slideIndex], audio: res.audio_url, isGenerating: false };
                            return newSlides;
                        });
                        setStatusMessage(`スライド ${slideIndex + 1} の音声生成完了`);
                    }
                } catch (e) {
                    setStatusMessage(`音声生成失敗: ${e.message}`);
                    setSlides(prev => {
                        const newSlides = [...prev];
                        newSlides[slideIndex] = { ...newSlides[slideIndex], isGenerating: false };
                        return newSlides;
                    });
                }
            };

            // Generate Video (動画生成)
            const generateVideo = async () => {
                if (isGeneratingVideo) return;

                if (!localBackendAvailable) {
                    setStatusMessage('ローカルバックエンドが起動していません。');
                    return;
                }

                // PDFファイル名から拡張子を除いた名前を取得
                const pdfBaseName = savedPdfName ? savedPdfName.replace(/\.pdf$/i, '') : 'output';

                setIsGeneratingVideo(true);
                setStatusMessage('動画生成中...');
                try {
                    const body = JSON.stringify({ 
                        resolution: selectedResolution,
                        output_name: pdfBaseName,
                        subtitle: subtitleEnabled,
                        format: videoFormat,
                        slides_count: slides.length,
                        scripts: slides.map((s, i) => ({ index: i, script: s?.script || '' }))
                    });
                    const res = await fetchJson('/api/generate_video', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body 
                    }, 600000);
                    
                    const list = await fetchJson('/api/list_outputs', {}, 4000);
                    const webm = (list && list.webm) ? list.webm : [];
                    const mp4 = (list && list.mp4) ? list.mp4 : [];
                    const files = [...webm, ...mp4].sort();
                    setOutputFiles(files);

                    const preferred = (res && (res.filename || res.webm || res.mp4)) ? (res.filename || res.webm || res.mp4) : '';
                    if (preferred && files.includes(preferred)) {
                        setSelectedOutputName(preferred);
                    } else if (files.length > 0) {
                        setSelectedOutputName(files[files.length - 1]);
                    }

                    const ext = (videoFormat || 'webm').toLowerCase();
                    setStatusMessage(`動画生成完了。output/${pdfBaseName}.${ext} に保存しました。`);
                } catch (e) {
                    setStatusMessage(`動画生成失敗: ${e.message}`);
                } finally {
                    setIsGeneratingVideo(false);
                }
            };

            // Update script
            const updateScript = (index, newScript) => {
                setSlides(prev => {
                    const newSlides = [...prev];
                    newSlides[index] = { ...newSlides[index], script: newScript, audio: null };
                    return newSlides;
                });
            };

            const activeSlide = slides[activeSlideIndex];

            return (
                <div className="h-screen bg-[#080b10] bg-grid text-slate-100 flex flex-col overflow-hidden">
                    
                    {/* Header */}
                    <header className="h-16 metal-panel backdrop-blur-md border-b border-white/10 flex items-center justify-between px-6 z-20 whitespace-nowrap">
                        <div className="flex items-center gap-3 flex-nowrap min-w-0">
                            <div className="w-9 h-9 bg-gradient-to-br from-amber-500 via-orange-500 to-amber-600 rounded-lg flex items-center justify-center shadow-lg shadow-amber-500/30">
                                <Video />
                            </div>
                            <h1 className="font-bold text-xs text-amber-200 drop-shadow">Slide Voice Maker</h1>
                            <button onClick={() => setShowHelp(true)} className="ml-2 text-amber-300 hover:text-white">
                                <HelpCircle />
                            </button>
                        </div>
                        
                        <div className="flex items-center gap-3 flex-nowrap overflow-x-auto">
                            {/* PDF入力ボタン */}
                            <button
                                onClick={() => fileInputRef.current?.click()}
                                className="flex items-center gap-2 px-3 py-2 bg-gradient-to-r from-amber-500 to-orange-600 hover:from-amber-400 hover:to-orange-500 text-black rounded-lg text-xs whitespace-nowrap border border-amber-300/60 shadow-lg shadow-amber-500/30"
                                title="PDFをアップロードしてスライドを展開します（input/へ保存）"
                            >
                                <Upload /> PDF入力
                            </button>
                            <input type="file" ref={fileInputRef} onChange={handlePdfUpload} accept=".pdf" className="hidden" />

                            {/* 原稿CSV入力ボタン */}
                            <button
                                onClick={() => csvInputRef.current?.click()}
                                className="flex items-center gap-2 px-3 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg text-xs whitespace-nowrap border border-amber-500/30"
                                title="原稿CSVをアップロードして入力したファイル名でinput/へ保存します"
                            >
                                <FileText /> 原稿CSV入力
                            </button>
                            <input type="file" ref={csvInputRef} onChange={handleCsvUpload} accept=".csv" className="hidden" />
                            
                            {/* 発音辞書ボタン */}
                            <button
                                onClick={() => dictInputRef.current?.click()}
                                className="flex items-center gap-2 px-3 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg text-xs whitespace-nowrap border border-purple-500/30"
                                title="発音辞書.csv入力（word,alias形式）"
                            >
                                <FileText /> 発音辞書
                            </button>
                            <input type="file" ref={dictInputRef} onChange={handleDictUpload} accept=".csv" className="hidden" />
                            
                            <div className="h-6 w-px bg-white/10 mx-1" />
                            
                            {/* 解像度選択 */}
                            <select
                                value={selectedResolution}
                                onChange={(e) => setSelectedResolution(e.target.value)}
                                className="px-3 py-2 bg-slate-900 hover:bg-slate-800 text-amber-200 rounded-lg text-xs whitespace-nowrap border border-amber-500/30 cursor-pointer"
                                title="画像解像度"
                            >
                                {RESOLUTION_OPTIONS.map(opt => (
                                    <option key={opt.value} value={opt.value}>{opt.label}</option>
                                ))}
                            </select>

                            {/* 男声/女声選択 */}
                            <select
                                value={voiceGender}
                                onChange={(e) => setVoiceGender(e.target.value)}
                                className="px-3 py-2 bg-slate-900 hover:bg-slate-800 text-amber-200 rounded-lg text-xs whitespace-nowrap border border-amber-500/30 cursor-pointer"
                                title="音声話者（Edge TTS: 4種類のプリセット、実際は2種類に自動マッピング）"
                            >
                                <optgroup label="女声">
                                    <option value="女声1">女声1（デフォルト・標準）</option>
                                    <option value="女声2">女声2（柔らか・共感的）</option>
                                    <option value="女声3">女声3（落ち着き・長尺向け）</option>
                                </optgroup>
                                <optgroup label="男声">
                                    <option value="男声1">男声1（デフォルト・標準）</option>
                                </optgroup>
                            </select>

                            {/* 画像・音声生成ボタン */}
                            <button
                                onClick={generateAllAudio}
                                disabled={isGeneratingAudio || !localBackendAvailable}
                                className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium text-xs whitespace-nowrap transition-all ${
                                    isGeneratingAudio 
                                        ? 'bg-slate-800 text-slate-400 cursor-wait' 
                                        : localBackendAvailable
                                            ? 'bg-gradient-to-r from-amber-500 to-orange-600 hover:from-amber-400 hover:to-orange-500 text-black shadow-lg shadow-amber-500/30'
                                            : 'bg-slate-800 text-slate-500 cursor-not-allowed'
                                }`}
                                title={localBackendAvailable ? '全スライドの画像・音声を生成し、output/temp/へ保存します' : 'バックエンドが起動していません'}
                            >
                                {isGeneratingAudio ? (
                                    <><Loader2 className="loading-spinner" /> 画像・音声生成中...</>
                                ) : (
                                    <><Wand2 /> 画像・音声生成</>
                                )}
                            </button>

                            {/* 字幕ON/OFFトグル */}
                            <div className="flex items-center gap-2 px-3 py-2 bg-slate-900 rounded-lg border border-amber-500/30">
                                <span className="text-xs text-amber-200">字幕</span>
                                <button
                                    onClick={() => setSubtitleEnabled(!subtitleEnabled)}
                                    className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                                        subtitleEnabled ? 'bg-amber-500' : 'bg-slate-600'
                                    }`}
                                    title={subtitleEnabled ? '字幕ON: 動画に字幕を埋め込みます' : '字幕OFF: 字幕なしで動画を生成します'}
                                >
                                    <span
                                        className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                                            subtitleEnabled ? 'translate-x-6' : 'translate-x-1'
                                        }`}
                                    />
                                </button>
                            </div>

                            {/* 出力形式（WebM/MP4） */}
                            <select
                                value={videoFormat}
                                onChange={(e) => setVideoFormat(e.target.value)}
                                className="px-3 py-2 bg-slate-900 hover:bg-slate-800 text-amber-200 rounded-lg text-xs whitespace-nowrap border border-amber-500/30 cursor-pointer"
                                title="動画の出力形式: WebM=軽量・高速 / MP4=互換性重視"
                            >
                                <option value="webm">WebM</option>
                                <option value="mp4">MP4</option>
                            </select>

                            {/* 動画生成ボタン */}
                            <button
                                onClick={generateVideo}
                                disabled={isGeneratingVideo || !localBackendAvailable}
                                className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium text-xs whitespace-nowrap transition-all ${
                                    isGeneratingVideo 
                                        ? 'bg-slate-800 text-slate-400 cursor-wait' 
                                        : localBackendAvailable
                                            ? 'bg-gradient-to-r from-orange-500 via-amber-500 to-orange-600 hover:from-orange-400 hover:to-amber-500 text-black shadow-lg shadow-orange-500/30'
                                            : 'bg-slate-800 text-slate-500 cursor-not-allowed'
                                }`}
                                title={localBackendAvailable ? '動画を生成し、output/へ保存します' : 'バックエンドが起動していません'}
                            >
                                {isGeneratingVideo ? (
                                    <><Loader2 className="loading-spinner" /> 動画生成中...</>
                                ) : (
                                    <><Video /> 動画生成</>
                                )}
                            </button>

                            <div className="h-6 w-px bg-white/10 mx-1" />

                            {/* 原稿CSV出力ボタン */}
                            <button
                                onClick={downloadCsv}
                                className="flex items-center gap-2 px-3 py-2 bg-slate-900 hover:bg-slate-800 text-amber-200 rounded-lg text-xs whitespace-nowrap border border-amber-500/30"
                                title="編集した原稿をCSVでダウンロード"
                            >
                                <Download /> 原稿CSV出力
                            </button>

                            {/* PPTX出力ボタン */}
                            <button
                                onClick={exportPptx}
                                disabled={slides.length === 0}
                                className="flex items-center gap-2 px-3 py-2 bg-slate-900 hover:bg-slate-800 text-amber-200 rounded-lg text-xs whitespace-nowrap border border-amber-500/30 disabled:opacity-50"
                                title="現在のスライド画像をPPTXとしてダウンロード（ブラウザ生成）"
                            >
                                <Download /> PPTX出力
                            </button>

                            {/* 動画出力（WebM/MP4） */}
                            {localBackendAvailable && (
                                <>
                                    <select
                                        value={selectedOutputName}
                                        onChange={(e) => setSelectedOutputName(e.target.value)}
                                        onFocus={refreshOutputFiles}
                                        className="px-3 py-2 bg-slate-900 hover:bg-slate-800 text-amber-200 rounded-lg text-xs whitespace-nowrap border border-amber-500/30 cursor-pointer"
                                        title={selectedOutputName ? `選択中: ${selectedOutputName}` : 'output/ にある動画（WebM/MP4）を選択'}
                                    >
                                        <option value="">(動画を選択)</option>
                                        {outputFiles.map(n => (
                                            <option key={n} value={n}>{shortenOutputLabel(n)}</option>
                                        ))}
                                    </select>
                                    <button
                                        onClick={downloadSelectedVideo}
                                        disabled={!selectedOutputName}
                                        className="flex items-center gap-2 px-3 py-2 bg-gradient-to-r from-orange-500 via-amber-500 to-orange-600 hover:from-orange-400 hover:to-amber-500 text-black rounded-lg text-xs whitespace-nowrap disabled:opacity-50 shadow-lg shadow-amber-500/30"
                                        title="選択した動画（WebM/MP4）をダウンロード"
                                    >
                                        <Download /> 動画出力
                                    </button>
                                </>
                            )}
                        </div>
                    </header>
                    
                    {/* Status Message */}
                    {statusMessage && (
                        <div className="bg-slate-900/70 border-b border-amber-500/20 px-6 py-2 text-sm text-amber-200">
                            {statusMessage}
                        </div>
                    )}
                    
                    {/* Main Content */}
                    <div className="flex-1 flex overflow-hidden">
                        {/* Sidebar */}
                        <div className="w-64 metal-panel border-r border-amber-500/25 flex flex-col">
                            <div className="p-4 border-b border-amber-500/25">
                                <h2 className="text-xs font-bold text-amber-300 uppercase tracking-wider">
                                    Slides ({slides.length})
                                </h2>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2 custom-scrollbar">
                                {slides.length === 0 && (
                                    <div className="text-center text-slate-500 text-sm px-3 py-6 border border-dashed border-amber-500/30 rounded-lg">
                                        PDFをアップロードするとスライドがここに表示されます。
                                    </div>
                                )}
                                {slides.map((slide, index) => (
                                    <div key={slide.id} className={`w-full p-2 rounded-lg transition-all border ${
                                        activeSlideIndex === index
                                            ? 'bg-slate-900 border-amber-500/50 shadow-md shadow-amber-500/25'
                                            : 'hover:bg-slate-900/70 border-transparent hover:border-amber-500/30'
                                    }`}>
                                        <button
                                            onClick={() => setActiveSlideIndex(index)}
                                            className="w-full text-left"
                                        >
                                            <div className="flex gap-3">
                                                <div className="relative w-16 aspect-video bg-[#0b0f16] rounded overflow-hidden border border-amber-500/30 flex-shrink-0">
                                                    <img src={slide.image} className="w-full h-full object-cover" alt={`Slide ${index + 1}`} />
                                                    {slide.isGenerating && (
                                                        <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
                                                            <Loader2 className="loading-spinner text-white" />
                                                        </div>
                                                    )}
                                                </div>
                                                <div className="flex-1 min-w-0 flex flex-col justify-center">
                                                    <span className="text-sm font-medium text-amber-200 truncate">Slide {index + 1}</span>
                                                    <div className="flex items-center gap-2 mt-1">
                                                        {slide.audio ? (
                                                            <span className="text-[10px] flex items-center gap-1 text-amber-300"><Volume2 /> Audio</span>
                                                        ) : (
                                                            <span className="text-[10px] flex items-center gap-1 text-orange-400"><FileText /> Text</span>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        </button>
                                        {/* スライド個別の画像・音声操作ボタン */}
                                        <div className="flex gap-1 mt-2">
                                            <button
                                                onClick={(e) => { e.stopPropagation(); generateSlideAudio(index); }}
                                                disabled={slide.isGenerating || !localBackendAvailable}
                                                className="flex-1 flex items-center justify-center gap-1 px-2 py-1 bg-gradient-to-r from-amber-500 to-orange-600 hover:from-amber-400 hover:to-orange-500 disabled:bg-slate-700 disabled:text-slate-500 text-black text-[10px] rounded"
                                                title="この1スライドの画像・音声を生成"
                                            >
                                                {slide.isGenerating ? <Loader2 className="loading-spinner w-3 h-3" /> : <Wand2 className="w-3 h-3" />}
                                                {slide.isGenerating ? '生成中...' : '画像・音声'}
                                            </button>
                                            {slide.audio && (
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        setActiveSlideIndex(index);
                                                        setTimeout(() => {
                                                            if (audioRef.current) {
                                                                audioRef.current.playbackRate = playbackRate;
                                                                audioRef.current.play().catch(() => {});
                                                            }
                                                        }, 100);
                                                    }}
                                                    className="flex items-center justify-center gap-1 px-2 py-1 bg-emerald-600 hover:bg-emerald-500 text-white text-[10px] rounded"
                                                    title="音声を再生"
                                                >
                                                    <Play className="w-3 h-3" />
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        {/* Preview Area */}
                        <div className="flex-1 flex flex-col bg-[#080b10] relative overflow-hidden">
                            <div className="flex-1 flex flex-col min-h-0">
                                <div className="flex-1 bg-[#0b0f16] relative flex items-center justify-center p-4">
                                    <div className="relative w-full h-full max-w-5xl flex flex-col items-center justify-center group">
                                        <div className="shadow-2xl rounded-lg border border-amber-500/25 bg-[#0b0c12] flex flex-col flex-shrink-1 min-h-0">
                                                        {/* 画像 + 再生ボタンは相対配置コンテナ内にまとめる */}
                                                        <div className="relative rounded-lg overflow-hidden">
                                                            {activeSlide ? (
                                                                        <img src={activeSlide?.image} className="max-w-full max-h-[calc(100vh-440px)] object-contain mx-auto" alt="Slide Preview" />
                                                            ) : (
                                                                        <div className="w-[720px] h-[405px] flex items-center justify-center text-slate-600 text-sm border border-dashed border-amber-500/25 rounded-lg">
                                                                    PDFをアップロードしてプレビューを表示
                                                                </div>
                                                            )}
                                                <audio 
                                                    ref={audioRef} 
                                                    src={activeSlide?.audio || ""} 
                                                    onLoadedMetadata={() => { if(audioRef.current) audioRef.current.playbackRate = playbackRate; }}
                                                    onPlay={() => setIsPlaying(true)} 
                                                    onPause={() => setIsPlaying(false)} 
                                                    onEnded={() => { setIsPlaying(false); if(audioRef.current) audioRef.current.currentTime = 0; }} 
                                                />
                                                {activeSlide?.audio && (
                                                    <div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 ${isPlaying ? 'opacity-0 group-hover:opacity-100' : 'opacity-100'}`}>
                                                        <button
                                                            onClick={() => {
                                                                const audio = audioRef.current;
                                                                if (!audio) return;
                                                                if (isPlaying) audio.pause();
                                                                else audio.play().catch(() => {});
                                                            }}
                                                            className="w-16 h-16 bg-gradient-to-br from-amber-500 to-orange-600 hover:from-amber-400 hover:to-orange-500 text-black rounded-full flex items-center justify-center shadow-xl shadow-amber-500/30 backdrop-blur-sm transition-transform hover:scale-105"
                                                        >
                                                            {isPlaying ? <Square /> : <Play />}
                                                        </button>
                                                    </div>
                                                )}
                                            </div>

                                            {/* SLIDE番号 / 再生速度（画像に重ならないよう、画像の下に配置） */}
                                            <div className="mx-3 my-3 flex items-center justify-center gap-3 px-3 py-2 rounded-md bg-slate-900/70 border border-amber-500/25 text-sm font-mono text-amber-200 backdrop-blur-sm">
                                                <span className="text-amber-100">SLIDE {String(activeSlideIndex + 1).padStart(2, '0')} / {String(slides.length).padStart(2, '0')}</span>
                                                <div className="h-4 w-px bg-white/15" />
                                                <div className="flex items-center gap-2">
                                                    <span className="text-amber-200">速度</span>
                                                    <select
                                                        value={playbackRate}
                                                        onChange={(e) => setPlaybackRate(parseFloat(e.target.value))}
                                                        className="px-2 py-1 bg-slate-900 hover:bg-slate-800 text-amber-200 rounded text-sm whitespace-nowrap border border-amber-500/30 cursor-pointer"
                                                        title="再生速度"
                                                    >
                                                        <option value="0.5">0.5x</option>
                                                        <option value="0.75">0.75x</option>
                                                        <option value="1">1.0x</option>
                                                        <option value="1.25">1.25x</option>
                                                        <option value="1.5">1.5x</option>
                                                        <option value="1.75">1.75x</option>
                                                        <option value="2">2.0x</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    {/* Navigation */}
                                    <div className="absolute inset-x-4 top-1/2 -translate-y-1/2 flex justify-between pointer-events-none">
                                        <button
                                            onClick={() => setActiveSlideIndex(Math.max(0, activeSlideIndex - 1))}
                                            disabled={activeSlideIndex === 0}
                                            className="pointer-events-auto p-3 rounded-full bg-slate-900/50 hover:bg-slate-800 text-slate-300 backdrop-blur-sm transition-all disabled:opacity-0"
                                        >
                                            <ChevronLeft />
                                        </button>
                                        <button
                                            onClick={() => setActiveSlideIndex(Math.min(slides.length - 1, activeSlideIndex + 1))}
                                            disabled={activeSlideIndex === slides.length - 1}
                                            className="pointer-events-auto p-3 rounded-full bg-slate-900/50 hover:bg-slate-800 text-slate-300 backdrop-blur-sm transition-all disabled:opacity-0"
                                        >
                                            <ChevronRight />
                                        </button>
                                    </div>
                                </div>
                                
                                <PlayerOverlay currentSlide={activeSlide} audioRef={audioRef} isPlaying={isPlaying} />
                            </div>
                            
                            {/* Script Editor */}
                            <div className="h-[200px] bg-[#0d1119] flex flex-col flex-shrink-0 border-t border-amber-500/20">
                                <div className="flex items-center justify-between px-4 py-2 border-b border-amber-500/20 bg-slate-900/60">
                                    <span className="text-xs font-bold text-amber-300 uppercase tracking-wider flex items-center gap-2">
                                        <FileText /> Narration Script
                                    </span>
                                    <span className="text-xs text-amber-200/70">{activeSlide?.script?.length || 0} characters</span>
                                </div>
                                <textarea
                                    value={activeSlide?.script || ""}
                                    onChange={(e) => updateScript(activeSlideIndex, e.target.value)}
                                    className="flex-1 bg-[#0b0f16] p-4 text-amber-100 text-lg leading-relaxed resize-none focus:outline-none focus:bg-slate-900/60 transition-colors"
                                    placeholder="ここに読み上げ原稿を入力してください..."
                                    disabled={slides.length === 0}
                                />
                            </div>
                        </div>
                    </div>
                    
                    {/* Help Modal */}
                    {showHelp && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-slate-900 border border-white/10 rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden">
                                <div className="flex items-center justify-between p-6 border-b border-white/10">
                                    <h3 className="text-xl font-bold text-white">🔮 使い方ガイド</h3>
                                    <button onClick={() => setShowHelp(false)} className="text-slate-400 hover:text-white"><X /></button>
                                </div>
                                <div className="p-6 space-y-4">
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 1] PDFアップロード</h4>
                                        <p className="text-sm text-slate-300">ヘッダー左の「PDF入力」ボタンからPDFをアップロードすると、input/に保存しつつブラウザでスライド展開します。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 2] 原稿CSV入力</h4>
                                        <p className="text-sm text-slate-300">「index,script」形式のCSVを読み込むと、各スライドに原稿が割り当てられます。UTF-8/Shift_JIS対応。読み込み時に毎回input/原稿.csvへ上書き保存します。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 2.5] 発音辞書（オプション）</h4>
                                        <p className="text-sm text-slate-300">「word,alias」形式のCSVを読み込むと、音声生成時にSSML置換辞書として使用されます。例: JERA,ジェラ / 成果物,せいかぶつ。読み込み時にinput/発音辞書.csvへ保存します。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 3] 解像度と字幕・形式を選択</h4>
                                        <p className="text-sm text-slate-300">解像度プルダウン（720p/1080p/1440p）、男声/女声、字幕ON/OFF、動画形式（WebM/MP4）を選択します。男声/女声は画像・音声生成時の読み上げ話者に反映されます。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 4] 画像・音声生成</h4>
                                        <p className="text-sm text-slate-300">「画像・音声生成」ボタンでoutput/tempをクリアした上で全スライドの画像/音声を生成し、上書き保存します。各スライド単位の生成・再生ボタンもサイドバーに用意しています。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 5] 動画生成</h4>
                                        <p className="text-sm text-slate-300">「動画生成」ボタンでoutput/tempの素材から動画（WebM/MP4）を生成し、PDFと同名でoutputに保存します。字幕ONの場合はYouTube風の半透明背景字幕を焼き込みます。</p>
                                    </div>
                                    <div className="bg-slate-800/50 rounded-lg p-4 border border-white/5">
                                        <h4 className="font-bold text-violet-400 mb-2">[STEP 6] ダウンロード</h4>
                                        <p className="text-sm text-slate-300">「原稿CSV出力」で編集済み原稿をダウンロード。「動画出力」でoutputに保存されたWebM/MP4をダウンロードできます。PPTX出力も可能です。</p>
                                    </div>
                                </div>
                                <div className="p-4 bg-slate-950 border-t border-white/5 flex justify-end">
                                    <button onClick={() => setShowHelp(false)} className="px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg">閉じる</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                </div>
            );
        }

        // Render
        ReactDOM.createRoot(document.getElementById('root')).render(<SlideVoiceMaker />);
    </script>
</body>
</html>
